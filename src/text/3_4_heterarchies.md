---
ordinal: 3.4
title: Heterarchies
---

# 3.4 HETERARCHIES

A hierarchical society is like a tree in which the agent at each branch is exclusively responsible for the agents on the twigs that branch from it. This pattern is found in every field, because dividing work into parts like that is usually the easiest way to start solving a problem. It is easy to construct and understand such organizations because each agent has only a single job to do: it needs only to "look up" for instructions from its supervisor, then "look down" to get help from its subordinates.

But hierarchies do not always work. Consider that when two agents need to use each other's skills, then neither one can be "on top." Notice what happens, for example, when you ask your vision-system to decide whether the following left-side scene depicts three blocks &mdash; or only two.

![heterarchies](/images/ch3/3-3.png)

The agent See could answer that if it could _Move_ the front block out of the line of view. But, in the course of doing that, _Move_ might have to _See_ if there were any obstacles that might interfere with the arm's trajectory. At such a moment, _Move_ would be working for _See_, and _See_ would be working for _Move_, both at the same time. This would be impossible inside a simple hierarchy.

Most of the diagrams in the early parts of this book depict simple hierarchies. Later, we'll see more cross-connected rings and loops &mdash; when we are forced to consider the need for memory, which will become a constant subject of concern in this book. People often think of memory in terms of keeping records of the past, for recollecting things that happened in earlier times. But agencies also need other kinds of memory as well. _See_, for example, requires some sort of temporary memory in order to keep track of what next to do, when it starts one job before its previous job is done. If each of _See's_ agents could do only one thing at a time, it would soon run out of resources and be unable to solve complicated problems. But if we have enough memory, we can arrange our agents into circular loops and thus use the same agents over and over again to do parts of several different jobs at the same time.
